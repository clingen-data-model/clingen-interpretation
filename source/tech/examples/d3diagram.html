<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Example Diagram</title>
<style>
line {
  stroke: #999;
  stroke-opacity: 0.6;
}

line.secondary-link  {
  stroke: #99f;
}

.link-label text {
  font-family: sans-serif;
  font-size: 8pt;
  text-anchor: middle;
  alignment-baseline: middle;
}

.node rect {
  stroke: #000;
  fill: #dddddd;
  stroke-width: 1.5px;
  rx: 4px;
}

.attribute rect {
  stroke: #333;
  fill: #ffffff;
  rx: 4px
}

.node text {
  font-family: sans-serif;
  font-size: 10pt;
  text-anchor: middle;
  alignment-baseline: middle;
}

.attribute text {
  font-size: 6pt;
}
</style>
<body>
  <svg id="diagram" width="1600" height="800"></svg>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script>

var diagram = {};
if (window.location.hash) {
	var exampleId = window.location.hash.substring(1);
  d3.json('../../json/' + exampleId + '.json', function(error, tree) {
    if (error) throw error
    diagram = new DmwgDiagram(tree);
    diagram.update();
  });
} else {
	// should somehow display an error here...
}

function DmwgDiagram(tree) {
  this.svg = d3.select("svg#diagram"),
            width = +this.svg.attr("width"),
            height = +this.svg.attr("height");

  var node = this.svg.selectAll('.node'),
      link = this.svg.selectAll('.link'),
      link_label = this.svg.selectAll('.link-label');

  this.graph = generate_graph(tree);

  var simulation = d3.forceSimulation()
      .force("primary-link", d3.forceLink().id(function(d) { return d.id; }).distance(100))
      .force("attribute-link", d3.forceLink().id(function(d) { return d.id; }).distance(50))
      .force("charge", d3.forceManyBody().strength(-200))
  //    .force("collision", d3.forceCollide(function(d) { return d._height; }))
      .force("depth", d3.forceX().strength(0))
      .force("center", d3.forceCenter(width / 2, height / 2));

  this.restart = function () {
    simulation.alpha(0.3).restart();
  }

  this.node_filter = function (d) { return true; };

  this.update = function () {
    var node_filter = this.node_filter;
    var visible_nodes = this.graph.nodes.filter(node_filter);
    var visible_links = this.graph.links.filter(function (d) { return node_filter(d.target) })
    var max_depth = d3.max(visible_nodes, function (d) {return d.depth;});

    //var node = this.svg.selectAll('.node').data(visible_nodes);
    node = this.svg.selectAll('.node').data(visible_nodes, function (d) { return d.id; });
    node.exit().remove();
    var node_enter = node.enter().append('g')
      .attr("class", "node")
      .classed("attribute", function (d) { return d.attribute; })
      //.attr("width", 10).attr("height", 10)
      .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

    node_enter.append("rect")

    node_enter.append("text")
      //.attr("dy", "14px")
      .text(function (d) { return d.label; })
      .each(function (d) { d._width = this.getBBox().width + 6})
      .each(function (d) { d._height = this.getBBox().height + 6})
      ;

    node = node_enter.merge(node);
    //node.selectAll('text')
    //  .attr("x", function(d) { return -d._width/2; })
    //  .attr("y", function(d) { return -d._height/2; })

    //node.selectAll('rect')
    //  .attr("width", function(d) { return this.parentNode.getBBox().width});
    node.selectAll('rect')
      .attr("width", function(d) { return d._width })
      .attr("height", function(d) { return d._height })
      .attr("x", function (d) { return -d._width/2 })
      .attr("y", function (d) { return -d._height/2 })

    //var link = this.svg.selectAll('.link').data(visible_links, function (d) { return d.target.id; })
    link = this.svg.selectAll('.link').data(visible_links, function (d) { return d.id; })
    link.exit().remove();
    link = link.enter().append('line')
      .attr("class", function (d) { return d.class; } )
      .classed("link", true)
      //.attr("class", function (d) { return d.class; })
      .merge(link);

    //var link_label = this.svg.selectAll('.link-label').data(visible_links, function (d) { return d.target.id; });
    link_label = this.svg.selectAll('.link-label').data(visible_links, function (d) { return d.id; })
    link_label.exit().remove();
    link_label = link_label.enter().append("text")
      .attr("class", "link-label")
      .text(function (d) { return d.label; })
      .merge(link_label)

    simulation
      .nodes(visible_nodes)
      .on("tick", ticked);

    simulation.force("primary-link")
      .links(visible_links.filter(function (d) { return d.class == "primary-link"; }));

    simulation.force("attribute-link")
      .links(visible_links.filter(function (d) { return d.class == "attribute-link"; }));

    simulation.force("depth")
      .x(function(d) { return (width / (max_depth+1)) * (d.depth + 0.5); }).strength(0.8);

  }

  var ticked = function() {
    var k = 6 * this.alpha();

    link
        //.each(function(d) { d.source.y -= k, d.target.y += k; })
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    link_label
        .attr("x", function(d) { return (d.source.x+d.target.x)/2 })
        .attr("y", function(d) { return (d.source.y+d.target.y)/2 })

    node
        .attr("transform", function (d) {
          var bbox = this.getBBox();
          return "translate(" +
              d.x + ',' + d.y + ')';
              //(d.x - bbox.width/2) + "," +
              //(d.y - bbox.height/2) + ")";
        });
  }

  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }
}

function generate_graph(data) {
  var graph = {
    "nodes_hash": {},
    "nodes": [],
    "links": []
  }
  var root = _generate_graph(data, graph, 0);
  Object.keys(graph.nodes_hash).forEach(function (k) {
    graph.nodes.push(graph.nodes_hash[k]);
  })
  var id = 0;
  graph.links.forEach(function (d) { d.id = ++id; })
  return graph;
}

function _generate_graph(data, graph, depth) {
  var id = data['cg:id'] || 'UNNAMED'
  var node = {id: id, label: id, depth: depth, type: data['cg:type'] || "UNKNOWN_TYPE" };
  node.attributes = d3.map();
  if (id in graph.nodes_hash) {
    console.log("duplicate for node " + id);
    node = graph.nodes_hash[id];
  } else {
    graph.nodes_hash[id] = node;
  }
  Object.keys(data).forEach(function (k, index) {
    if ((k === 'explanation') || (k === 'description') || (k === 'cg:id') || (k === 'cg:type')) {
      return;
    }
    var v = data[k]

    if (typeof(v) === 'string' || typeof(v) === 'number' || typeof(v) === 'boolean') {
      if (k.startsWith('cg:')) {
        k = k.substring(3);
      }
      node.attributes.set(k, v);
    } else if (Array.isArray(v)) {
      v.forEach(function (x) {
        var link_class, child;
        if (x['cg:id'] in graph.nodes_hash) {
          child = graph.nodes_hash[x['cg:id']];
          child.depth = depth+1;
          link_class = 'secondary-link';
        } else {
          child = _generate_graph(x, graph, depth+1)
          link_class = 'primary-link';
        }
        graph.links.push({
          "source": node,
          "target": child,
          "label": k,
          "class": link_class
        })
      })
    } else {
      if (v['cg:id'] in graph.nodes_hash) {
        child = graph.nodes_hash[v['cg:id']];
        child.depth = depth+1;
        link_class = 'secondary-link';
      } else {
        child = _generate_graph(v, graph, depth+1)
        link_class = 'primary-link';
      }
      graph.links.push({
        "source": node,
        "target": child,
        "label": k,
        "class": link_class
      })
    }
  })
  node.attributes.each(function (v, k) {
    var a_node = {
      "label": v,
      "depth": depth + 0.2,
      "attribute": true
    };
    graph.nodes.push(a_node);
    graph.links.push({
      "source": id,
      "target": a_node,
      "label": k,
      "class": 'attribute-link'
    })
  })
  return node
}

	</script>
</body>
</html>
